<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IEEE 754 Float Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #61dafb;
        }

        .input-group {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        input[type="text"] {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            font-size: 1.1em;
            width: 400px;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            font-size: 1.1em;
        }

        .bits-container {
            display: flex;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            margin-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .bit-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 2px;
        }

        .bit {
            width: 20px;
            height: 25px;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #333;
        }

        .bit.sign {
            background: #ff6b6b;
            color: #000;
            font-weight: bold;
        }

        .bit.exp {
            background: #4ecdc4;
            color: #000;
            font-weight: bold;
        }

        .bit.mantissa {
            background: #ffe66d;
            color: #000;
            font-weight: bold;
        }

        .label {
            font-size: 0.7em;
            color: #aaa;
            margin-top: 2px;
        }

        .result-box {
            margin-top: 30px;
            padding: 15px;
            background: #333;
            border-radius: 4px;
        }

        .formula {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #a8dadc;
            margin-top: 10px;
        }

        .status {
            font-weight: bold;
            margin-top: 10px;
            font-size: 1.2em;
        }

        .denormal {
            color: #ff9f43;
        }

        .normal {
            color: #2ecc71;
        }

        .special {
            color: #ff6b6b;
        }

        .hidden-bit-box {
            margin-top: 10px;
            font-size: 0.9em;
            color: #888;
        }

        button {
            padding: 8px 12px;
            margin: 0 4px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        button:hover {
            background: #555;
        }
    </style>
</head>

<body>

    <div class="container">
        <h1>IEEE 754 Visualizer</h1>

        <div class="input-group">
            <label>Type:</label>
            <select id="typeSelect" onchange="updateFromInput()">
                <option value="float">Float (32-bit)</option>
                <option value="double">Double (64-bit)</option>
                <option value="bfloat">BFloat16 (16-bit)</option>
            </select>
            <label>Value:</label>
            <input type="text" id="inputVal" value="1.0" oninput="updateFromInput()" placeholder="Enter number">
        </div>

        <div class="input-group">
            <button onclick="setPreset('p0')">+0.0</button>
            <button onclick="setPreset('n0')">-0.0</button>
            <button onclick="setPreset('pinf')">+Inf</button>
            <button onclick="setPreset('ninf')">-Inf</button>
            <button onclick="setPreset('qnan')">qNaN</button>
            <button onclick="setPreset('snan')">sNaN</button>
            <button onclick="setPreset('denorm')">Min Denorm</button>
            <button onclick="setPreset('max')">Max</button>
        </div>

        <div id="bitsDisplay" class="bits-container"></div>

        <div class="result-box">
            <h3>Analysis</h3>
            <div id="status" class="status"></div>
            <div id="formula" class="formula"></div>
            <div id="breakdown"></div>
        </div>
    </div>

    <script>
        // Global state to hold the bits
        let currentBuffer = new ArrayBuffer(8);
        let currentView = new DataView(currentBuffer);

        function setPreset(preset) {
            const type = document.getElementById('typeSelect').value;
            const isFloat = type === 'float';
            const isDouble = type === 'double';
            // bfloat handled if not float/double

            currentView.setFloat64(0, 0); // Clear

            // Helper to determine active bits location
            // Float: 0..31
            // Double: 0..63
            // BFloat: 0..15 (Using first 2 bytes of buffer)

            if (preset === 'p0') {
                // 0
            } else if (preset === 'n0') {
                currentView.setUint8(0, 0x80);
            } else if (preset === 'pinf') {
                if (isFloat) currentView.setFloat32(0, Infinity);
                else if (isDouble) currentView.setFloat64(0, Infinity);
                else currentView.setUint16(0, 0x7F80); // BFloat Inf (same as float top 16)
            } else if (preset === 'ninf') {
                if (isFloat) currentView.setFloat32(0, -Infinity);
                else if (isDouble) currentView.setFloat64(0, -Infinity);
                else currentView.setUint16(0, 0xFF80);
            } else if (preset === 'qnan') {
                // Quiet NaN: Exp=Ones, MSB Mantissa=1
                if (isFloat) currentView.setUint32(0, 0x7FC00000);
                else if (isDouble) {
                    currentView.setUint32(0, 0x7FF80000);
                } else {
                    currentView.setUint16(0, 0x7FC0); // BFloat qNaN
                }
            } else if (preset === 'snan') {
                // Signaling NaN: Exp=Ones, MSB=0, but some bit is 1.
                // BFloat (7 mantissa bits): 0 11111111 0000001
                if (isFloat) currentView.setUint32(0, 0x7F800001);
                else if (isDouble) {
                    currentView.setUint32(0, 0x7FF00000);
                    currentView.setUint32(4, 0x00000001);
                } else {
                    currentView.setUint16(0, 0x7F81); // BFloat sNaN
                }
            } else if (preset === 'denorm') {
                // Min denormal
                if (isFloat) currentView.setUint32(0, 1);
                else if (isDouble) currentView.setUint32(4, 1);
                else currentView.setUint16(0, 1);
            } else if (preset === 'max') {
                // Max finite
                if (isFloat) currentView.setFloat32(0, 3.40282347e38);
                else if (isDouble) currentView.setFloat64(0, Number.MAX_VALUE);
                else currentView.setUint16(0, 0x7F7F); // Max BFloat (~3.38e38)
            }

            renderAndSync(type, true);
        }

        function updateFromInput() {
            const type = document.getElementById('typeSelect').value;
            const valStr = document.getElementById('inputVal').value;
            let val = parseFloat(valStr);

            if (valStr.trim().toLowerCase() === 'nan') val = NaN;
            if (valStr.trim().toLowerCase() === 'inf') val = Infinity;
            if (valStr.trim().toLowerCase() === '-inf') val = -Infinity;

            // Clear buffer
            currentView.setFloat64(0, 0);

            if (type === 'float') {
                currentView.setFloat32(0, val);
            } else if (type === 'double') {
                currentView.setFloat64(0, val);
            } else {
                // BFloat16: Convert Float32 -> BFloat16
                // Simple truncation: Top 16 bits of Float32
                // Rounding: Add 0x8000 to lower 16 bits before truncate, but beware overflow to exp
                // Let's implement Round-to-Nearest-Even (RTNE) simulation via simple truncation for now
                // or just set as float32 and take top 16 bits

                // Write as float32 to temp buffer
                let tmpBuf = new ArrayBuffer(4);
                let tmpView = new DataView(tmpBuf);
                tmpView.setFloat32(0, val);
                let u32 = tmpView.getUint32(0);

                // BFloat16 creation (Truncation for simplicity in visualizer to match "Casting")
                // Or usually: (u32 + 0x00008000) >> 16;
                // Let's use truncation as it's the strict "just the top bits" definition often used for quick explanation
                let bf16 = (u32 >>> 16) & 0xFFFF;

                // Check if wrapping affects exponent (rounding) - skipping for simplicity
                currentView.setUint16(0, bf16);
            }

            renderAndSync(type, false);
        }

        function toggleBit(bitIndex, type) {
            // bitIndex is visual index 0..N

            const byteIdx = Math.floor(bitIndex / 8);
            const bitInByte = 7 - (bitIndex % 8);

            const currentByte = currentView.getUint8(byteIdx);
            const newByte = currentByte ^ (1 << bitInByte);
            currentView.setUint8(byteIdx, newByte);

            renderAndSync(type, true); // true = update input text
        }

        function renderAndSync(type, updateInput) {
            const isFloat = type === 'float';
            const isDouble = type === 'double';
            const isBFloat = type === 'bfloat';

            // Read value back
            let val;
            if (isFloat) val = currentView.getFloat32(0);
            else if (isDouble) val = currentView.getFloat64(0);
            else {
                // BFloat -> Float32
                let u16 = currentView.getUint16(0);
                let u32 = u16 << 16;
                let tmpBuf = new ArrayBuffer(4);
                new DataView(tmpBuf).setUint32(0, u32);
                val = new DataView(tmpBuf).getFloat32(0);
            }

            if (updateInput) {
                document.getElementById('inputVal').value = val;
            }

            // Get bits string
            let bits = '';
            const len = isDouble ? 8 : (isFloat ? 4 : 2);
            for (let i = 0; i < len; i++) {
                let b = currentView.getUint8(i);
                for (let j = 7; j >= 0; j--) {
                    bits += ((b >> j) & 1) ? '1' : '0';
                }
            }

            renderBits(bits, type);
        }

        function renderBits(bits, type) {
            const container = document.getElementById('bitsDisplay');
            container.innerHTML = '';

            const isDouble = type === 'double';
            const isFloat = type === 'float';
            const isBFloat = type === 'bfloat';

            let expLen, bias;
            if (isDouble) {
                expLen = 11;
                bias = 1023;
            } else if (isFloat || isBFloat) { // BFloat16 has same exponent as Float32
                expLen = 8;
                bias = 127;
            }

            // BFloat: 1 S, 8 E, 7 M

            // Sign
            addBitBox(container, bits[0], 'S', 'sign', 0, type);

            // Exponent
            for (let i = 0; i < expLen; i++) {
                addBitBox(container, bits[1 + i], 'E', 'exp', 1 + i, type);
            }

            // Mantissa
            const mStart = 1 + expLen;
            const mBits = bits.substring(mStart);
            for (let i = 0; i < mBits.length; i++) {
                addBitBox(container, mBits[i], 'M', 'mantissa', mStart + i, type);
            }

            // Analysis
            const eBits = bits.substring(1, 1 + expLen);
            const expVal = parseInt(eBits, 2);

            const statusEl = document.getElementById('status');
            const formulaEl = document.getElementById('formula');
            let status = '';
            let formula = '';
            let formulaClass = '';

            const sBit = bits[0];

            // Check for All Ones Exponent
            if (isAllOnes(eBits)) {
                if (mBits.indexOf('1') !== -1) {
                    status = "NaN (Not a Number)";
                    formulaClass = "special";
                    if (mBits[0] === '1') status += " [Quiet]";
                    else status += " [Signaling]";
                } else {
                    status = (sBit === '1' ? "-" : "+") + "Infinity";
                    formulaClass = "special";
                }
            } else if (isAllZeros(eBits)) {
                if (mBits.indexOf('1') === -1) {
                    status = "Zero";
                    formulaClass = "special";
                    formula = (sBit === '1' ? "-" : "+") + "0.0";
                } else {
                    status = "Denormal (Subnormal)";
                    formulaClass = "denormal";
                    const trueExp = 1 - bias;
                    // For BFloat, Mantissa is 7 bits
                    const manLen = mBits.length;
                    // formula = `(-1)^${sBit} × 0.${mBits} × 2^(${trueExp})`;
                    formula = `(-1)^${sBit} × 0.${mBits.substring(0, Math.min(manLen, 8))}... × 2^(${trueExp})`;
                    formula += `<br>Implicit Bit: 0`;
                }
            } else {
                status = "Normalized";
                formulaClass = "normal";
                const trueExp = expVal - bias;
                const manLen = mBits.length;
                formula = `(-1)^${sBit} × 1.${mBits.substring(0, Math.min(manLen, 8))}... × 2^(${expVal} - ${bias} = ${trueExp})`;
                formula += `<br>Implicit Bit: 1`;
            }

            statusEl.className = "status " + formulaClass;
            statusEl.innerHTML = status;
            formulaEl.innerHTML = formula;
        }

        function isAllOnes(str) { return str.indexOf('0') === -1; }
        function isAllZeros(str) { return str.indexOf('1') === -1; }

        function addBitBox(container, val, label, type, index, typeMode) {
            const div = document.createElement('div');
            div.className = 'bit-box';
            // Add onclick handler
            div.onclick = function () { toggleBit(index, typeMode); };
            div.style.cursor = 'pointer';
            div.innerHTML = `<div class="bit ${type}">${val}</div><div class="label">${label}</div>`;
            div.title = `Click to toggle bit ${index}`;
            container.appendChild(div);
        }

        // Init
        updateFromInput();
    </script>

</body>

</html>